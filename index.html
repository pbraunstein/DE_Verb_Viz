<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>German Verb Viz</title>
	<link href="http://fonts.googleapis.com/css?family=Merienda+One" rel="stylesheet" type="text/css">
	<link href="http://fonts.googleapis.com/css?family=Pacifico" rel="stylesheet" type="text/css">
	<script type="text/javascript" src="libs/d3/d3.min.js"></script>
</head>
<style>
	.node {
		stroke: #fff;
		stroke-width: 1.5px;
	}

	.node text {
		  pointer-events: none;
  		  font: 25px Merienda;
	}

	.link {
		stroke: #999;
		stroke-opacity: .6;
	}
</style>
<body>
	<script>
		var color = d3.scale.category20();
		var data;
		var width = 1000;
		var height = 800;
		var nodeRad = 30;
		var HUB_SCALE_FACTOR = 3;
		var TRANS_DURATION = 1000;
		var svg = d3.select("body").append("svg")
					.attr("width", width)
					.attr("height", height)

		d3.json("data/data.json", function(error, json){
			if (error) return console.warn(error);
			data = json;
			vizIt();
		});

		function vizIt() {
			buildFDG(data[1]);
		}

		function buildFDG(preTree) {
			var fdg = d3.layout.force()
				.gravity(0.05)
				.charge(-1000)
				.size([width, height]);
			nodes = [];
			i = 1;

			// Get length of root
			rootLength = preTree.root.length;

			// Create hub node
			nodes.push({"name":preTree.root, "group":i++, "hub":true})

			// Create all of the surrounding nodes
			preTree.childWords.forEach(function(word) {
				nodes.push({"name":word.verb, "group":i++,"hub":false});
			});

			links = [];
			// Create links
			for (i = 1; i < nodes.length; i++){
				var newLink = {"source":0, "target":i, "value":6}
				// Index is one behind, because childWords doesn't
				// include the hub node root
				newLink.separ = preTree.childWords[i - 1].separ;
				links.push(newLink);
			}

			fdg.nodes(nodes).links(links).linkDistance(function(thisLink){
				if (thisLink.separ) {
					return 300;}
				else {
					return 150;
				}
			  }).start();

			// draw lines for links
			var link = svg.selectAll(".link")
						  .data(links)
						  .enter().append("line")
						  .attr("class", "link")
						  .style("stroke-dasharray", function(d) {if (d.separ) {return 10} else {return 0}})
      					  .style("stroke-width", function(d) { if (d.separ) {return Math.sqrt(d.value);} else {return d.value}});

      		//draw circles for nodes
			var node = svg.selectAll(".node")
						  .data(nodes)
						  .enter().append("g")
						  .attr("class", "node")
						  .call(fdg.drag);

			node.append("circle")		  
						  .attr("r", function(d){
						  	// hubs should be bigger
						  	if (d.hub) {
						  		return HUB_SCALE_FACTOR * nodeRad;
						  	} else {
						  		return nodeRad;
						  	}
						  })
						  .style("fill", function(d) { return color(d.group); });

			// Draw the text label
		  	node.append("text")
		  		.attr("text-anchor", "middle")
		  		.attr("dy", ".35em")
		  		.style("fill", "gray")
		  		.style("stroke", "black")
		  		.on("click", function() {
		  			console.log("CLICK");
		  		})
		  		.text(function(d) {
		  			if (d.hub) {
		  				return d.name;
		  			} else {
		  				return d.name.slice(0, -rootLength);
		  			}


		  		});

		  	// Create tooltip
		  	node.append("title")
		  		.text(function(d) {return d.name});

		  	node.on("click", function(d){
		  		// Transition
		  		d3.select(this).select("circle").transition().duration(TRANS_DURATION)
		  		  .attr("r", 2 * d3.select(this).select("circle").attr("r"))
		  		  .style("opacity", 0.3);
		  		d3.select(this).select("text").transition().duration(TRANS_DURATION)
		  		  .style("fill", "black")
		  		  .style("stroke", "gray");


		  		// Pause, and then transition back to normal
		  		d3.select(this).select("circle").transition().delay(3000).duration(TRANS_DURATION)
		  		  .attr("r", d3.select(this).select("circle").attr("r"))
		  		  .style("opacity", 1);
		  		d3.select(this).select("text").transition().delay(3000).duration(TRANS_DURATION)
		  		  .style("fill", "gray")
		  		  .style("stroke", "black");

		  	})


		  	fdg.on("tick", function() {
			    link.attr("x1", function(d) { return d.source.x; })
			        .attr("y1", function(d) { return d.source.y; })
			        .attr("x2", function(d) { return d.target.x; })
			        .attr("y2", function(d) { return d.target.y; });

			     node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
			});
		}

	function getRandomPos(isXCoord) {
		if (isXCoord) {
			Math.floor(Math.random() * width);
		} else {  // Is height
			Math.floor(Math.random() * height);
		}
	}

	</script>
</body>
</html>